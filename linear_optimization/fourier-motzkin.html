<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Adrian Neumann (adrian_neumann@gmx.de)" />
  <title>Solving Linear Programs</title>
  <style type="text/css">
  .displayequation{margin-left:auto;margin-right:auto;}
  </style>
  <style>
  .caption{font-size:66%;text-align:right;}
  .figure{float:right;padding-bottom:1em;padding-left:1em;}
  .figure>img{display:block;margin:0 auto;}
  .footnotes{font-size:80%;}
  .block{border-left:1ex solid gray;padding-left:2em;}
  li{padding:0.25em;}
  a:hover{text-shadow: 0 0 5px;}
  body{font-family:sans-serif;max-width:100ex;padding-left:3em;padding-right:2em;}
  code{font-family:Consolas, Inconsolata, Monaco, monospace;}
  p{text-align:justify;}
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Solving Linear Programs</h1>
</div>
<p>Recall from the introduction that a linear program is defined by a linear objective function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>c</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">f(x) = c_1x_1+c_2x_2+\ldots+c_nx_n</annotation></semantics></math> and a set of constraints <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_{i1}x_1+a_{i2}x_2+a_{in}x_n \le b_i</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">1\le i\le m</annotation></semantics></math>. For reasons that will become clear in a few paragraphs (and even clearer in the next part of this series), I will write the variables as a column vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><msup><mo stretchy="false" form="postfix">)</mo><mtext mathvariant="normal">T</mtext></msup></mrow><annotation encoding="application/x-tex">\vec x=(x_1,\ldots, x_n)^\text{T}</annotation></semantics></math>, where I use the superscript <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> to indicate transposition so that I can write column vectors in the rows of this text.</p>
<p>When we treat the variables as a vector like this, it makes sense to call the number of variables the <em>dimension</em> of the LP. I will call vectors that satisfy all constraints <em>feasible</em>. If there is no such vector, the problem is <em>infeasible</em>.</p>
<h3 id="solving-1d-linear-programs-by-combining-constraints">Solving 1D Linear Programs by combining constraints</h3>
<p>Solving 1-dimensional LPs is trivial. We have just one variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. The cost function either becomes bigger as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> increases or smaller, so we immediately know whether we’re looking for the biggest <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> that satisfies the constraints or the smallest. The set of feasible <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is then the intersection of the rays defined be the constraints. For example</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mo>min</mo></mtd><mtd columnalign="left"><mn>3</mn><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mtext mathvariant="normal">s.t.</mtext></mtd><mtd columnalign="left"><mi>x</mi><mo>≥</mo><mn>3</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>x</mi><mo>≥</mo><mn>5</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>x</mi><mo>≤</mo><mn>7</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\min &amp; 3x \\
\text{s.t.} &amp; x\ge 3 \\
    &amp; x\ge 5 \\
    &amp; x\le 7
\end{aligned}</annotation></semantics></math></p>
<p>The constant before the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in the cost function is positive, so in order to minimize the objective value we need to minimize <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. The constraints can be simplified to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>≥</mo><mi>x</mi><mo>≥</mo><mn>5</mn><mo>≥</mo><mn>3</mn><mo accent="false">→</mo><mi>x</mi><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><mn>5</mn><mo>,</mo><mn>7</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">7 \ge x \ge 5 \ge 3 \rightarrow x\in [5,7]</annotation></semantics></math> and thus the optimal value is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">x=5</annotation></semantics></math>.</p>
<h3 id="solving-2d-linear-programs-by-eye-balling">Solving 2D Linear Programs by Eye-Balling</h3>
<p>In two dimensions we can use a very similar strategy. The cost function still tells us in which direction to move <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>x</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec x</annotation></semantics></math> and the intersection of the constraints gives us a feasible region. We use a graphical approach to see the set of feasible values for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>.</p>
<p>If you write an equals sign like this <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_{i1}x_1+a_{i2}x_2+a_{in}x_n = b_i</annotation></semantics></math>, you get an <a href="https://en.wikipedia.org/wiki/Linear_equation#General_.28or_standard.29_form">equation for a line</a>. If you write the constants as a vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec a=(a_{i1}, \ldots, a_{in})</annotation></semantics></math>, you can write the line equation using the dot product: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>x</mi><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a\cdot x=b_i</annotation></semantics></math>. Note that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> is orthogonal to the line. Why is that so? Take some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> that lies on the line, i.e. it solves the above equation. Moving <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> by some amount <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> along the line results in a vector that lies on the line and hence still satisfies the equation. The dot product is distributive so we can write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mo>⋅</mo><mi>x</mi><mo>+</mo><mi>a</mi><mo>⋅</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a \cdot (x+z)= a\cdot x + a\cdot z</annotation></semantics></math>. We know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>x</mi><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a\cdot x=b_i</annotation></semantics></math> (since this is how we chose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>), so the second summand must be zero. <a href="https://en.wikipedia.org/wiki/Dot_product#Properties">When the dot product is zero, the two vectors are orthogonal.</a></p>
<p>Now consider what happens to the equation when we take an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> from the line and move it by some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> that is not parallel to the line. It depends on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⋅</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a\cdot z</annotation></semantics></math>. If the dot product is positive, the left hand side becomes too big for the equality, otherwise it becomes too small. The dot product is positive if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> points somewhat in the same direction as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> (more formally, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> can be decomposed in two vectors, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">z&#39;</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>″</mi></mrow><annotation encoding="application/x-tex">z&#39;&#39;</annotation></semantics></math>, such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">z&#39;</annotation></semantics></math> is orthogonal to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mi>″</mi></mrow><annotation encoding="application/x-tex">z&#39;&#39;</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\lambda a</annotation></semantics></math> for some <em>positive</em> real <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>).</p>
<p>So if we take the original inequality, it cuts the 2D plane in two parts, left and right from the line. Which part satisfies the inequality depends on the direction of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> and whether we have a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\ge</annotation></semantics></math> or a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\le</annotation></semantics></math>. The set of points that satisfy the inequality is called a halfplane.</p>
<p>The feasible region of the problem, i.e. all the points that satisfy all constraints, is then the intersection of all the halfplanes.</p>
<p>The cost function also defines a line, or rather, a family of lines, one for each objective value, namely the solutions for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">f(x)=z</annotation></semantics></math> for each objective value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>. If the intersection of this line with the feasible region is not empty, there is a solution (any point in the intersection) with cost <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>. The cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> is orthogonal to the line defined by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>. The goal is to shift the line as far in negative <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> direction as possible without leaving the feasible region. Take for example the following LP</p>
<div class="figure">
<img src="./images/graphSolutionEx.png" title="Fig:graphSolutionEx" alt="Fig:graphSolutionEx An example for a graphical solution of an LP. The optimal solution is (3,2)" />
<p class="caption">Fig:graphSolutionEx An example for a graphical solution of an LP. The optimal solution is (3,2)</p>
</div>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mo>min</mo></mtd><mtd columnalign="left"><mi>x</mi><mo>+</mo><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>s</mi><mi>.</mi><mi>t</mi><mi>.</mi></mtd><mtd columnalign="left"><mn>2</mn><mi>x</mi><mo>+</mo><mi>y</mi><mo>≥</mo><mn>8</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mi>y</mi><mo>≥</mo><mn>12</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\min &amp; x+y\\
s.t. &amp;2x+y\geq 8\\
     &amp;2x+3y\geq 12\end{aligned}</annotation></semantics></math></p>
<p>The cost vector is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">c=(1,1)</annotation></semantics></math> and the two constraints define two half-planes. For every value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> of the cost function, we have a line <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x+y=z</annotation></semantics></math>. See figure [Fig:graphSolutionEx]. We want to find the smallest value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math> is a feasible solution. So we start with some arbitrary <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math> in the feasible region (picking it is the eye-balling step) and then gradually move it in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">-c</annotation></semantics></math> direction (i.e. we subtract small multiples of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>). Once we find that we can’t move our solution any further without leaving the feasible region, we have reached the optimum.</p>
<p>A somewhat weaker operation than picking a feasible <em>solution</em> to LP is picking an objective value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> and finding out whether this objective value can be achieved.</p>
<p>To do so, we can add a new constraint, namely <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>≤</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">f(x) \le z</annotation></semantics></math>. This constraint adds another half-plane that constrains the feasible region. If this makes the feasible region empty, there is no solution with an objective value at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>. If the feasible region still contains more than one point, then we can decrease <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> a little more. We have reached the optimal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> if the feasible region contains only one point. Now, if we had a method to check whether a feasible region is empty or not, this would give us an algorithm to solve linear programs with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false" form="prefix">(</mo><mo>log</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>z</mi><mtext mathvariant="normal">opt</mtext></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">O(\log (z_{\text{opt}}))</annotation></semantics></math> many evaluations of the feasibility algorithm.</p>
<h3 id="fourier-motzkin-elimination">Fourier-Motzkin Elimination</h3>
<p>Now that we know how to solve 1D LPs rigorously and 2D LPs with a graphical method, let us try to find a method that works for arbitrary dimensions. As we already can solve low-dimensional LPs, it makes sense to try and get there via dimensionality reduction.</p>
<p>Fourier-Motzkin elimination is a method to reduce the dimension of an LP by one without changing feasibility. If we keep reducing the dimension one by one, we eventually reach the 1D case, where we can test feasibility easily. The objective value is disregarded by this method, we only care about feasibility. By adding an additional constraint as described above we can transform the optimization problem to a feasibility problem. In an exercise you will show how to reconstruct an optimal solution.</p>
<p>The method works by rearranging the constraints to solve for one variable and then introducing enough new constraints to make the variable unnecessary. As an example we will use this 2D LP.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mtext mathvariant="normal">max</mtext></mtd><mtd columnalign="left"><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mtext mathvariant="normal">s.t.</mtext></mtd><mtd columnalign="left"><mn>2</mn><mi>x</mi><mo>+</mo><mn>7</mn><mi>y</mi></mtd><mtd columnalign="right"><mo>≤</mo><mn>28</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mn>4</mn><mi>x</mi><mo>−</mo><mn>2</mn><mi>y</mi></mtd><mtd columnalign="right"><mo>≥</mo><mn>20</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>x</mi><mo>+</mo><mi>y</mi></mtd><mtd columnalign="right"><mo>≥</mo><mn>6</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>y</mi></mtd><mtd columnalign="right"><mo>≥</mo><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\text{max} &amp; y \\
\text{s.t.} &amp;  2x + 7y &amp;\le 28 \\
            &amp;  4x - 2y  &amp;\ge 20 \\
            &amp;  x   + y  &amp; \ge 6\\
            &amp;          y  &amp;\ge 0
\end{aligned}            
</annotation></semantics></math></p>
<p><strong>Exercise</strong>: Draw the feasible region for this LP.</p>
<p>We want to eliminate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>. So first we rearrange all constraints to have just <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> on the left side. We get</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≤</mo><mn>4</mn><mo>−</mo><mn>2</mn><mi>x</mi><mi>/</mi><mn>7</mn></mtd></mtr><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≤</mo><mo>−</mo><mn>10</mn><mo>+</mo><mn>2</mn><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≥</mo><mn>6</mn><mo>−</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≥</mo><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
y &amp; \le  4 - 2x/7\\
y &amp;\le -10 + 2x\\
y &amp;\ge 6 - x\\
y &amp;\ge 0
\end{aligned}</annotation></semantics></math></p>
<p>Now we can combine the constraints where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>≤</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">y\le \ldots</annotation></semantics></math> with the constraints where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>≥</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">y\ge \ldots</annotation></semantics></math>. As we have two of each, we get four constraints.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mn>4</mn><mo>−</mo><mn>2</mn><mi>x</mi><mi>/</mi><mn>7</mn></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>6</mn><mo>−</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mn>4</mn><mo>−</mo><mn>2</mn><mi>x</mi><mi>/</mi><mn>7</mn></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="right"><mo>−</mo><mn>10</mn><mo>+</mo><mn>2</mn><mi>x</mi></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>6</mn><mo>−</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>−</mo><mn>10</mn><mo>+</mo><mn>2</mn><mi>x</mi></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
4 - 2x/7 &amp;\ge y \ge 6 - x \\
4 - 2x/7 &amp;\ge y \ge 0\\
-10 + 2x &amp;\ge y \ge 6 - x \\
-10 + 2x &amp;\ge y \ge 0
\end{aligned}
</annotation></semantics></math></p>
<p><strong>Exercise</strong> Add these constraints to your picture.</p>
<p>We can simplify to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mi>x</mi><mi>/</mi><mn>7</mn><mo>≥</mo><mn>2</mn><mspace width="1.0em"></mspace><mn>2</mn><mi>x</mi><mi>/</mi><mn>7</mn><mo>≤</mo><mn>4</mn><mspace width="1.0em"></mspace><mn>3</mn><mi>x</mi><mo>≥</mo><mn>16</mn><mspace width="1.0em"></mspace><mn>2</mn><mi>x</mi><mo>≥</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">  5x/7 \ge 2  \quad 2x/7 \le 4 \quad 3x \ge 16  \quad 2x \ge 10 </annotation></semantics></math></p>
<p>which further simplifies to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mn>14</mn><mi>/</mi><mn>5</mn><mspace width="1.0em"></mspace><mi>x</mi><mo>≤</mo><mn>14</mn><mspace width="1.0em"></mspace><mi>x</mi><mo>≥</mo><mn>16</mn><mi>/</mi><mn>3</mn><mspace width="1.0em"></mspace><mi>x</mi><mo>≥</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">  x \ge 14/5 \quad x \le 14 \quad x \ge 16/3 \quad x \ge 5 </annotation></semantics></math></p>
<p>and lastly</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>max</mo><mo stretchy="false" form="prefix">(</mo><mn>14</mn><mi>/</mi><mn>5</mn><mo>,</mo><mn>16</mn><mi>/</mi><mn>3</mn><mo>,</mo><mn>5</mn><mo stretchy="false" form="postfix">)</mo><mo>≤</mo><mi>x</mi><mo>≤</mo><mo>min</mo><mo stretchy="false" form="prefix">(</mo><mn>14</mn><mo stretchy="false" form="postfix">)</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">   \max(14/5,16/3,5) \le x \le \min(14). </annotation></semantics></math></p>
<p>If you did the exercise above correctly, you will see that projecting the feasible region down to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> axis leaves you with the interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">5\le x \le 14</annotation></semantics></math>. Note that the simplification we did to the constraints after eliminating <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> was in fact the procedure to eliminate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. A 0-dimensional LP has no variables, just a bunch of inequalities involving numbers and the feasibility check is just some calculation.</p>
<p><strong>Exercise</strong>: Instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>, eliminate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>. Does your result match your picture?</p>
<p>In general Fourier-Motzkin elimination works as follows:</p>
<ol style="list-style-type: decimal">
<li>Pick a variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> to eliminate.</li>
<li>Rearrange all constraints to have only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> on the left side. You get three kinds on inequalities:
<ol style="list-style-type: decimal">
<li>Inequalities that don’t contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math></li>
<li>Inequalities that bound <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> from above.</li>
<li>Inequalities that bound <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> from below.</li>
</ol></li>
<li>Keep type 1 inequalities.</li>
<li>For each type 2 inequality, take all type 3 inequalities and write down the combined inequality.</li>
</ol>
<p><strong>Exercise</strong>: Use Fourier-Motzkin Elimination to find not just the optimal objective value, but also the optimal solution.</p>
<p>Let’s try to prove that Fourier-Motzkin Elimination is correct, that is, it reduces the dimension by one, without changing satisfiability. Let us first define the projection of a set of vectors. Since we can choose the order of our variables without changing the problem, it suffices to deal with the case where we drop the last coordinate of each vector.</p>
<p><strong>Definition</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\vec x = (x_1, \ldots, x_n)</annotation></semantics></math> be a vector. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(\vec x) = (x_1,\ldots,x_{n-1})</annotation></semantics></math> is the projection of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> on the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math> coordinates. For a set of vectors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>, let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">|</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\pi(S) = \{\pi(x) | x \in S \}</annotation></semantics></math> be the set where we apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math> on every element.</p>
<p>It is easy to see that for any non-empty set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(S)</annotation></semantics></math> is also non-empty. So if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> is the feasible set of our linear program, projecting it down doesn’t change feasibility. So far so good. Unfortunately we don’t have the feasible region given as a point set, it’s given by the inequalities. Hence we need to use Fourier Motzkin elimination instead of just dropping a coordinate. Next we will show that Fourier Motzkin elimination indeed computes the projection.</p>
<p><strong>Proof</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> be the feasible region of our LP, and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math> be the feasible region of the LP after we remove the last variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> via Fourier Motzkin Elimination. We show <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Q=\pi(S)</annotation></semantics></math>. We do so by proving mutual inclusion, that is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>Q</mi><mo accent="false">⇒</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)\in Q \Rightarrow \pi(x) \in \pi(S)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">⇒</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>Q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x) \in \pi(S) \Rightarrow \pi(x) \in \pi(Q)</annotation></semantics></math></p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">⇒</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\pi(x) \in \pi(S) \Rightarrow \pi(x) \in Q</annotation></semantics></math>. That means we have a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(S)</annotation></semantics></math> and we want to find a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math> that corresponds to it. In <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> the vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> has another component, so let us write in a slight abuse of notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x = (\pi(x),x_n)</annotation></semantics></math>. We don’t know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> (and there are in general many <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">x\in S</annotation></semantics></math> that get mapped to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math>) but we know that it had to satisfy the constraints.</p>
<p>There are three kinds of constraints in our LP after we rearrange the inequalities to have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> only on the left hand side, as explained above. Type 1 constraints don’t contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> and hence have no influence on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math>, so if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> satisfies them <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math> also satisfies them. For type 2 and type 3 inequalities, we know that there is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> that satisfies <em>all</em> of them.</p>
<p>We constructed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math> by combining type 2 and type 3 constraints. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math> be the r.h.s. of the tightest type 2 constraint, that is, the constraint where the right hand side evaluates to the smallest number when we plug in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\pi(x) = x_1,\ldots,x_{n-1}</annotation></semantics></math>, and similarly let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>3</mn></msub><annotation encoding="application/x-tex">T_3</annotation></semantics></math> be the r.h.s. of the tightest type 3 constraint. Note that then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_3 \le T_2</annotation></semantics></math> is the tightest constraint for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math> that we have in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math>. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> satisfies all constraints, we know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_3 \le x_n \le T_2</annotation></semantics></math> and hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_3 \le T_2</annotation></semantics></math>. Thus <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math> satisfies the constraints for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math> and hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\pi(x) \in Q</annotation></semantics></math>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>Q</mi><mo accent="false">⇒</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)\in Q \Rightarrow \pi(x) \in \pi(S)</annotation></semantics></math>. For this direction also we have to choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>n</mi></msub><annotation encoding="application/x-tex">x_n</annotation></semantics></math> so that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x=(\pi(x),x_n)</annotation></semantics></math> satisfies the constraints for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>. As in the other direction let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>2</mn></msub><annotation encoding="application/x-tex">T_2</annotation></semantics></math> be the r.h.s. of the tightest type 2 constraint, and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mn>3</mn></msub><annotation encoding="application/x-tex">T_3</annotation></semantics></math> be the r.h.s. of the tightest type 3 constraint. Then we can simply choose any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>∈</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>T</mi><mn>3</mn></msub><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">x_n \in [T_3, T_2]</annotation></semantics></math>. This interval can’t be empty, because we have the constraint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_3 \le T_2</annotation></semantics></math> in our constraint set for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Q</mi><annotation encoding="application/x-tex">Q</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math> satisfies all of those constraints.</p></li>
</ol>
<p>And this concludes our proof.</p>
<p>So with Fourier Motzkin elimination we have a method of checking feasibility for Linear Programs: Eliminate dimensions until no variables remain and do the math to see whether each inequality is satisfied. Together with your method for transforming optimization to repeated feasibility, we can now solve Linear Programming. Unfortunately Fourier Motzkin Elimination gets pretty expensive for large dimensions as you’ll see in the next exercise.</p>
<p><strong>Exercise</strong> What’s the runtime of an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-step Fourier Motzkin Elimination? Hint: How many constraints do you introduce in each step?</p>
<p><a href="polyhedra.html">Next part: Polyhedra</a><br />
<a href="../linear_optimization.html">Click here to go back to the index</a></p>
<div style="font-size:80%">
<hr/>
<p style="float:left">CC-BY-SA <a href="mailto:adrian_neumann@gmx.de">Adrian Neumann</a> (PGP Key <a href="http://adriann.github.io/ressources/pub.asc">A210311B</a>)</p>
<p style="float:right"><a href="http://adriann.github.io">adriann.github.io</a></p>
</div>
</body>
</html>
