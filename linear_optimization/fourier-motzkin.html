<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Adrian Neumann (adrian_neumann@gmx.de)" />
  <title>Solving Linear Programs</title>
  <script type="text/javascript">/*<![CDATA[*/
  /*
  March 19, 2004 MathHTML (c) Peter Jipsen http://www.chapman.edu/~jipsen
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  
  function convertMath(node) {// for Gecko
    if (node.nodeType==1) {
      var newnode =
        document.createElementNS("http://www.w3.org/1998/Math/MathML",
          node.nodeName.toLowerCase());
      for(var i=0; i < node.attributes.length; i++)
        newnode.setAttribute(node.attributes[i].nodeName,
          node.attributes[i].value);
      for (var i=0; i<node.childNodes.length; i++) {
        var st = node.childNodes[i].nodeValue;
        if (st==null || st.slice(0,1)!=" " && st.slice(0,1)!="\n")
          newnode.appendChild(convertMath(node.childNodes[i]));
      }
      return newnode;
    }
    else return node;
  }
  
  function convert() {
    var mmlnode = document.getElementsByTagName("math");
    var st,str,node,newnode;
    for (var i=0; i<mmlnode.length; i++)
      if (document.createElementNS!=null)
        mmlnode[i].parentNode.replaceChild(convertMath(mmlnode[i]),mmlnode[i]);
      else { // convert for IE
        str = "";
        node = mmlnode[i];
        while (node.nodeName!="/MATH") {
          st = node.nodeName.toLowerCase();
          if (st=="#text") str += node.nodeValue;
          else {
            str += (st.slice(0,1)=="/" ? "</m:"+st.slice(1) : "<m:"+st);
            if (st.slice(0,1)!="/")
               for(var j=0; j < node.attributes.length; j++)
                 if (node.attributes[j].value!="italic" &&
                   node.attributes[j].value!="" &&
                   node.attributes[j].value!="inherit" &&
                   node.attributes[j].value!=undefined)
                   str += " "+node.attributes[j].nodeName+"="+
                       "\""+node.attributes[j].value+"\"";
            str += ">";
          }
          node = node.nextSibling;
          node.parentNode.removeChild(node.previousSibling);
        }
        str += "</m:math>";
        newnode = document.createElement("span");
        node.parentNode.replaceChild(newnode,node);
        newnode.innerHTML = str;
      }
  }
  
  if (document.createElementNS==null) {
    document.write("<object id=\"mathplayer\"\
    classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
    document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
  }
  if(typeof window.addEventListener != 'undefined'){
    window.addEventListener('load', convert, false);
  }
  if(typeof window.attachEvent != 'undefined') {
    window.attachEvent('onload', convert);
  }
  /*]]>*/
  </script>
  <style type="text/css">
  .displayequation{margin-left:auto;margin-right:auto;}
  </style>
  <style>
  .caption{font-size:66%;text-align:right;}
  .figure{float:right;padding-bottom:1em;padding-left:1em;}
  .figure>img{display:block;margin:0 auto;}
  .footnotes{font-size:80%;}
  li{padding:0.25em;}
  a:hover{text-shadow: 0 0 5px;}
  body{font-family:sans-serif;max-width:100ex;padding-left:3em;padding-right:2em;}
  code{font-family:Consolas, Inconsolata, Monaco, monospace}
  p{text-align:justify;}
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Solving Linear Programs</h1>
</div>
<p>Recall from the introduction that a linear program is defined by a linear objective function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>c</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>c</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub></mrow></math> and a set of constraints <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>2</mn></mrow></msub><mi>x</mi><mn>2</mn><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><msub><mi>b</mi><mi>i</mi></msub></mrow></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi></mrow></math>. For reasons that will become clear in a few paragraphs (and even clearer in the next part of this series), I will write the variables as a column vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><msup><mo stretchy="false">)</mo><mtext mathvariant="normal">T</mtext></msup></mrow></math>, where I use the superscript <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi></mrow></math> to indicate transposition so that I can write column vectors in the rows of this text.</p>
<p>When we treat the variables as a vector like this, it makes sense to call the number of variables the <em>dimension</em> of the LP. I will call vectors that satisfy all constraints <em>feasible</em>. If there is no such vector, the problem is <em>infeasible</em>.</p>
<h3 id="solving-1d-linear-programs-by-combining-constraints">Solving 1D Linear Programs by combining constraints</h3>
<p>Solving 1-dimensional LPs is trivial. We have just one variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>. The cost function either becomes bigger as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> increases or smaller, so we immediately now whether we’re looking for the biggest <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> that satisfies the constraints or the smallest. The set of feasible <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> is then the intersection of the rays defined be the constraints. For example</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="right"><mi>min</mi></mtd><mtd columnalign="left"><mn>3</mn><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mtext mathvariant="normal">s.t.</mtext></mtd><mtd columnalign="left"><mi>x</mi><mo>≥</mo><mn>3</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>x</mi><mo>≥</mo><mn>5</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>x</mi><mo>≤</mo><mn>7</mn></mtd></mtr></mtable></mrow></math></p>
<p>The constant before the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> in the cost function is positive, so in order to minimize the objective value we need to minimize <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>. The constraints can be simplified to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>7</mn><mo>≥</mo><mi>x</mi><mo>≥</mo><mn>5</mn><mo>≥</mo><mn>3</mn><mo>→</mo><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>5</mn><mo>,</mo><mn>7</mn><mo stretchy="false">]</mo></mrow></math> and thus the optimal value is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>=</mo><mn>5</mn></mrow></math>.</p>
<h3 id="solving-2d-linear-programs-by-eye-balling">Solving 2D Linear Programs by Eye-Balling</h3>
<p>In two dimensions we can use a very similar strategy. The cost function still tells us in which direction to move <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>x</mi><mo accent="true">⃗</mo></mover></mrow></math> and the intersection of the constraints gives us a feasible region. We use a graphical approach to see the set of feasible values for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>.</p>
<p>The constraints define halfplanes in the 2D space. If you write an equals sign instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>≤</mo></mrow></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>≥</mo></mrow></math>), you get an equation for a line. The inequality is valid for all points on one side of the line. Which side depends on the weights on the left side (more precisely, on the direction defined by the vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow></math>) and whether it’s a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>≤</mo></mrow></math> or a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>≥</mo></mrow></math>. The feasible region of the problem, i.e. all the points that satisfy all constraints, is then the intersection of all the halfplanes.</p>
<p>The cost function defines a line parameterized by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>x</mi><mo accent="true">⃗</mo></mover></mrow></math> (i.e. the line with cost <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>). If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> lies within the feasible region we get a feasible solution. The cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi></mrow></math> is orthogonal to the line defined by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi></mrow></math>. The goal is to shift the line as far in negative <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi></mrow></math> direction as possible without leaving the feasible region. Take for example the following LP</p>
<div class="figure">
<img src="./images/graphSolutionEx.png" title="Fig:graphSolutionEx" alt="Fig:graphSolutionEx An example for a graphical solution of an LP. The optimal solution is (3,2)" /><p class="caption">Fig:graphSolutionEx An example for a graphical solution of an LP. The optimal solution is (3,2)</p>
</div>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="right"><mi>min</mi></mtd><mtd columnalign="left"><mi>x</mi><mo>+</mo><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>s</mi><mo>.</mo><mi>t</mi><mo>.</mo></mtd><mtd columnalign="left"><mn>2</mn><mi>x</mi><mo>+</mo><mi>y</mi><mo>≥</mo><mn>8</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mn>2</mn><mi>x</mi><mo>+</mo><mn>3</mn><mi>y</mi><mo>≥</mo><mn>12</mn></mtd></mtr></mtable></mrow></math></p>
<p>The cost vector is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></math> and the two constraints define two half-planes. For every value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math> of the cost function, we have a line <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow></math>. See figure [Fig:graphSolutionEx]. We want to find the smallest value of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></math> is a feasible solution. So we start with some arbitrary <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></math> in the feasible region (picking it is the eye-balling step) and then gradually move it in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>−</mo><mi>c</mi></mrow></math> direction (i.e. we subtract small multiples of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi></mrow></math>). Once we find that we can’t move our solution any further without leaving the feasible region, we have reached the optimum.</p>
<p>A somewhat weaker operation than picking a feasible <em>solution</em> to LP is picking an objective value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math> and finding out whether this objective value can be achieved.</p>
<p>To do so, we can add a new constraint, namely <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>z</mi></mrow></math>. This constraint adds another half-plane that constraints the feasible region. If this makes the feasible region empty, there is no solution with at objective value at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math>. If the feasible region still contains more than one point, then we can decrease <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math> a little more. We have reached the optimal <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi></mrow></math> if the feasible region contains only one point. Now, if we had a method to check whether a feasible region is empty or not, this would give us an algorithm to solve linear programs with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo stretchy="false">(</mo><msub><mi>z</mi><mtext mathvariant="normal">opt</mtext></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></math> many evaluations of the feasibility algorithm.</p>
<h3 id="fourier-motzkin-elimination">Fourier-Motzkin Elimination</h3>
<p>Now that we know how to solve 1D LPs rigorously and 2D LPs with a graphical method, let us try to find a method that works for arbitrary dimensions. As we already can solve low-dimensional LPs, it makes sense to try and get there via dimensionality reduction.</p>
<p>Fourier-Motzkin elimination is a method to reduce the dimension of an LP by one without changing feasibility. If we keep reducing the dimension one by one, we eventually reach the 1D case, where we can test feasibility easily. The objective value is disregarded by this method, we only care about feasibility. By adding an additional constraint as described above we can transform the optimization problem to a feasibility problem. In an exercise you will show how to reconstruct an optimal solution.</p>
<p>The method works by rearranging the constraints to solve for one variable and then introducing enough new constraints to make the variable unnecessary. As an example we will use this 2D LP.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="right"><mtext mathvariant="normal">max</mtext></mtd><mtd columnalign="left"><mi>y</mi></mtd></mtr><mtr><mtd columnalign="right"><mtext mathvariant="normal">s.t.</mtext></mtd><mtd columnalign="left"><mn>2</mn><mi>x</mi><mo>+</mo><mn>7</mn><mi>y</mi></mtd><mtd><mo>≤</mo><mn>28</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mn>4</mn><mi>x</mi><mo>−</mo><mn>2</mn><mi>y</mi></mtd><mtd><mo>≥</mo><mn>20</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>x</mi><mo>+</mo><mi>y</mi></mtd><mtd><mo>≥</mo><mn>6</mn></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mi>y</mi></mtd><mtd><mo>≥</mo><mn>0</mn></mtd></mtr></mtable></mrow></math></p>
<p><strong>Exercise</strong>: Draw the feasible region for this LP.</p>
<p>We want to eliminate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math>. So first we rearrange all constraints to have just <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> on the left side. We get</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≤</mo><mn>4</mn><mo>−</mo><mn>2</mn><mi>x</mi><mo>/</mo><mn>7</mn></mtd></mtr><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≤</mo><mo>−</mo><mn>10</mn><mo>+</mo><mn>2</mn><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≥</mo><mn>6</mn><mo>−</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>y</mi></mtd><mtd columnalign="left"><mo>≥</mo><mn>0</mn></mtd></mtr></mtable></mrow></math></p>
<p>Now we can combine the constraints where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>≤</mo><mo>…</mo></mrow></math> with the constraints where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>≥</mo><mo>…</mo></mrow></math>. As we have two of each, we get four constraints.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="right"><mn>4</mn><mo>−</mo><mn>2</mn><mi>x</mi><mo>/</mo><mn>7</mn></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>6</mn><mo>−</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mn>4</mn><mo>−</mo><mn>2</mn><mi>x</mi><mo>/</mo><mn>7</mn></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="right"><mo>−</mo><mn>10</mn><mo>+</mo><mn>2</mn><mi>x</mi></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>6</mn><mo>−</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="right"><mo>−</mo><mn>10</mn><mo>+</mo><mn>2</mn><mi>x</mi></mtd><mtd columnalign="left"><mo>≥</mo><mi>y</mi><mo>≥</mo><mn>0</mn></mtd></mtr></mtable></mrow></math></p>
<p>We can simplify to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>5</mn><mi>x</mi><mo>/</mo><mn>7</mn><mo>≥</mo><mn>2</mn><mspace width="1em"></mspace><mn>2</mn><mi>x</mi><mo>/</mo><mn>7</mn><mo>≤</mo><mn>4</mn><mspace width="1em"></mspace><mn>3</mn><mi>x</mi><mo>≥</mo><mn>16</mn><mspace width="1em"></mspace><mn>2</mn><mi>x</mi><mo>≥</mo><mn>10</mn></mrow></math></p>
<p>which further simplifies to</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>≥</mo><mn>14</mn><mo>/</mo><mn>5</mn><mspace width="1em"></mspace><mi>x</mi><mo>≤</mo><mn>14</mn><mspace width="1em"></mspace><mi>x</mi><mo>≥</mo><mn>16</mn><mo>/</mo><mn>3</mn><mspace width="1em"></mspace><mi>x</mi><mo>≥</mo><mn>5</mn></mrow></math></p>
<p>and lastly</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>max</mi><mo stretchy="false">(</mo><mn>14</mn><mo>/</mo><mn>5</mn><mo>,</mo><mn>16</mn><mo>/</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>min</mi><mo stretchy="false">(</mo><mn>14</mn><mo stretchy="false">)</mo><mo>.</mo></mrow></math></p>
<p>If you did the exercise above correctly, you will see that projecting the feasible region down to the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> axis leaves you with the interval <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>5</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mn>14</mn></mrow></math>. Note that the simplification we did to the constraints after eliminating <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> was in fact the procedure to eliminate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>. A 0-dimensional LP has no variables, just a bunch of inequalities involving numbers and the feasibility check is just some calculation.</p>
<p><strong>Exercise</strong>: Instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math>, eliminate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math>. Does your result match your picture?</p>
<p>In general Fourier-Motzkin elimination works as follows:</p>
<ol style="list-style-type: decimal">
<li>Pick a variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> to eliminate.</li>
<li>Rearrange all constraints to have only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> on the left side. You get three kinds on inequalities:
<ol style="list-style-type: decimal">
<li>Inequalities that don’t contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math></li>
<li>Inequalities that bound <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> from above.</li>
<li>Inequalities that bound <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi></mrow></math> from below.</li>
</ol></li>
<li>Keep type 1 inequalities.</li>
<li>For each type 2 inequality, take all type 3 inequalities and write down the combined inequality.</li>
</ol>
<p><strong>Exercise</strong>: Use Fourier-Motzkin Elimination to find not just the optimal objective value, but also the optimal solution.</p>
<p>Let’s try to prove that Fourier-Motzkin Elimination is correct, that is, it reduces the dimension by one, without changing satisfiability. Let us first define the projection of a set of vectors. Since we can choose the order of our variables without changing the problem, it suffices to deal with the case where we drop the last coordinate of each vector.</p>
<p><strong>Definition</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math> be a vector. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow></math> is the projection of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> on the first <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></math> coordinates. For a set of vectors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi></mrow></math>, let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">∣</mo><mi>x</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow></math> be the set where we apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi></mrow></math> on every element.</p>
<p>It is easy to see that for any non-empty set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi></mrow></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></math> is also non-empty. So if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi></mrow></math> is the feasible set of our linear program, projecting it down doesn’t change feasibility. So far so good. Unfortunately we don’t have the feasible region given as a point set, it’s given by the inequalities. Hence we need to use Fourier Motzkin elimination instead of just dropping a coordinate. Next we will show that Fourier Motzkin elimination indeed computes the projection.</p>
<p><strong>Proof</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi></mrow></math> be the feasible region of our LP, and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi></mrow></math> be the feasible region of the LP after we remove the last variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> via Fourier Motzkin Elimination. We show <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mo>=</mo><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></math>. We do so by proving mutual inclusion, that is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Q</mi><mo>⇒</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false">(</mo><mi>Q</mi><mo stretchy="false">)</mo></mrow></math></p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Q</mi></mrow></math>. That means we have a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></math> and we want to find a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi></mrow></math> that corresponds to it. In <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi></mrow></math> the vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> has another component, so let us write in a slight abuse of notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math>. We don’t know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> (and there are in general many <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>∈</mo><mi>S</mi></mrow></math> that get mapped to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math>) but we know that it had to satisfy the constraints.</p>
<p>There are three kinds of constraints in our LP after we rearrange the inequalities to have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> only on the left hand side, as explained above. Type 1 constraints don’t contain <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> and hence have no influence on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math>, so if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi></mrow></math> satisfies them <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> also satisfies them. For type 2 and type 3 inequalities, we know that there is an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> that satisfies <em>all</em> of them.</p>
<p>We constructed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi></mrow></math> by combining type 2 and type 3 constraints. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow></math> be the r.h.s. of the tightest type 2 constraint, that is, the constraint where the right hand side evaluates to the smallest number when we plug in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></math>, and similarly let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>3</mn></msub></mrow></math> be the r.h.s. of the tightest type 3 constraint. Note that then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow></math> is the tightest constraint for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> that we have in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi></mrow></math>. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> satisfies all constraints, we know <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>x</mi><mi>n</mi></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow></math> and hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow></math>. Thus <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> satisfies the constraints for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi></mrow></math> and hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Q</mi></mrow></math>.</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Q</mi><mo>⇒</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>π</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow></math>. For this direction also we have to choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></math> so that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow></math> satisfies the constraints for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi></mrow></math>. As in the other direction let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow></math> be the r.h.s. of the tightest type 2 constraint, and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>3</mn></msub></mrow></math> be the r.h.s. of the tightest type 3 constraint. Then we can simply choose any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>n</mi></msub><mo>∈</mo><mo stretchy="false">[</mo><msub><mi>T</mi><mn>3</mn></msub><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">]</mo></mrow></math>. This interval can’t be empty, because we have the constraint <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi><mn>3</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow></math> in our constraint set for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi></mrow></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math> satisfies all of those constraints.</p></li>
</ol>
<p>And this concludes our proof.</p>
<p>So with Fourier Motzkin elimination we have a method of checking feasibility for Linear Programs: Eliminate dimensions until no variables remain and do the math to see whether each inequality is satisfied. Together with your method for transforming optimization to repeated feasibility, we can now solve Linear Programming. Unfortunately Fourier Motzkin Elimination gets pretty expensive for large dimensions as you’ll see in the next exercise.</p>
<p><strong>Exercise</strong> What’s the runtime of an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow></math>-step Fourier Motzkin Elimination? Hint: How many constraints do you introduce in each step?</p>
<p>Next part coming soon<br /><a href="../linear_optimization.html">Click here to go back to the index</a></p>
<div style="font-size:80%">
<hr/>
<p style="float:left">CC-BY-SA <a href="mailto:adrian_neumann@gmx.de">Adrian Neumann</a> (PGP Key <a href="http://adriann.github.io/ressources/pub.asc">A210311B</a>)</p>
<p style="float:right"><a href="http://adriann.github.io">adriann.github.io</a></p>
</div>
</body>
</html>
