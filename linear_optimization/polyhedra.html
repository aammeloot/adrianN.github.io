<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="https://adriann.github.io/feed.rss" rel="alternate" type="application/rss+xml" title="What's new on adriann.github.io" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Adrian Neumann (adrian_neumann@gmx.de)" />
  <title>Linear Programs and Polyhedra</title>
  <style type="text/css">
  .displayequation{margin-left:auto;margin-right:auto;}
  </style>
  <style>
  .caption{font-size:66%;text-align:right;}
  .figure{float:right;padding-bottom:1em;padding-left:1em;}
  .figure>img{display:block;margin:0 auto;}
  .footnotes{font-size:80%;}
  .block{border-left:1ex solid gray;padding-left:2em;}
  li{padding:0.25em;}
  a:hover{text-shadow: 0 0 5px;}
  body{font-family:sans-serif;max-width:100ex;padding-left:3em;padding-right:2em;}
  code{font-family:Consolas, Inconsolata, Monaco, monospace;}
  p{text-align:justify;}
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Linear Programs and Polyhedra</h1>
</div>
<p>In the previous section we saw how the feasible region of a linear program is constructed as the intersection of a number of halfplanes, one for each constraint. Using this insight we developed a graphical approach for solving 2D LPs. Together with Fourier-Motzkin elimination as a means for reducing the dimensionality of an LP, this gave us a general method for solving linear programs.</p>
<p>Unfortunately Fourier-Motzkin produces a rather large number of constraints, so it is unsuited for solving problems with many variables.</p>
<p>In this section I will talk more about the properties of the feasible region. With more knowledge about the feasible region, we’ll eventually be able to understand a very popular method for solving linear programs, the Simplex Method.</p>
<p>Let us start by introducing some notation and some terms.</p>
<p>Already in the last part we started writing the variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,\ldots, x_n</annotation></semantics></math> as a column vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>x</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec x</annotation></semantics></math> and the constants <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">a_{ij}</annotation></semantics></math> as a row vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\vec a_i</annotation></semantics></math>. We did the same with the cost function, writing the weights for each variable as a row vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>c</mi><mo accent="true">⃗</mo></mover><annotation encoding="application/x-tex">\vec c</annotation></semantics></math>. This way we could use the dot product instead of writing sums explicitly.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mi>i</mi></msub><mo>⋅</mo><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo>=</mo><msub><mi>a</mi><mrow><mi>i</mi><mn>1</mn></mrow></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi>…</mi><mo>+</mo><msub><mi>a</mi><mrow><mi>i</mi><mi>n</mi></mrow></msub><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex"> \vec a_i \cdot \vec x = a_{i1}x_1+\ldots+a_{in}x_n</annotation></semantics></math></p>
<p>The constraints can be written using a matrix vector product. We write the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><annotation encoding="application/x-tex">a_{ji}</annotation></semantics></math> in a matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> like so</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="right"><msub><mi>a</mi><mn>11</mn></msub></mtd><mtd columnalign="left"><msub><mi>a</mi><mn>12</mn></msub></mtd><mtd columnalign="right"><mi>…</mi></mtd><mtd columnalign="left"><msub><mi>a</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right"><msub><mi>a</mi><mn>21</mn></msub></mtd><mtd columnalign="left"><mi>…</mi></mtd></mtr><mtr><mtd columnalign="right"><mi>⋮</mi></mtd><mtd columnalign="left"></mtd></mtr><mtr><mtd columnalign="right"><msub><mi>a</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub></mtd><mtd columnalign="left"><mi>…</mi></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"><msub><mi>a</mi><mrow><mi>m</mi><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
A=\left(\begin{aligned}
a_{11} &amp; a_{12} &amp; \ldots &amp; a_{1n}\\
a_{21} &amp; \ldots \\
\vdots &amp; \\
a_{m1} &amp; \ldots &amp; &amp; a_{mn} \end{aligned}\right)
</annotation></semantics></math></p>
<p>Note that the rows of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> are simply the vectors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>a</mi><mo accent="true">⃗</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\vec a_i</annotation></semantics></math>.</p>
<p>Now we can write the constraints simply as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>x</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Ax\le b</annotation></semantics></math>, where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> is a column vector of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>b</mi><mi>j</mi></msub><annotation encoding="application/x-tex">b_j</annotation></semantics></math>. Summarizing we get the general form of a linear program:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mtext mathvariant="normal">minimize:</mtext></mtd><mtd columnalign="left"><mover><mi>c</mi><mo accent="true">⃗</mo></mover><mo>⋅</mo><mover><mi>x</mi><mo accent="true">⃗</mo></mover></mtd></mtr><mtr><mtd columnalign="right"><mtext mathvariant="normal">subject to:</mtext></mtd><mtd columnalign="left"><mi>A</mi><mo>⋅</mo><mover><mi>x</mi><mo accent="true">⃗</mo></mover><mo>≤</mo><mover><mi>b</mi><mo accent="true">⃗</mo></mover></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
\text{minimize:}&amp; \vec c \cdot \vec x \\
\text{subject to:} &amp; A \cdot \vec x \le \vec b\end{aligned}</annotation></semantics></math></p>
<p>Note that it really doesn’t matter whether we use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\le</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\ge</annotation></semantics></math>. Just multiplying by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math> switches a constraint around without changing it.</p>
<div class="block">
<p><strong>Def</strong> A <em>polyhedron</em> is a set in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup><annotation encoding="application/x-tex">\text{R}^n</annotation></semantics></math> whose members obey a set of linear inequalities <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup><mo stretchy="false" form="prefix">|</mo><mi>A</mi><mi>x</mi><mo>≥</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo><mspace width="2.0em"></mspace><mi>A</mi><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow></msup><mo>,</mo><mspace width="0.222em"></mspace><mi>b</mi><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">\{x\in \text{R}^n | Ax \geq b\} \qquad A\in \text{R}^{m\times n},\ b\in \text{R}^m</annotation></semantics></math> If the region is bounded (i.e. it has a finite volume) it can also be called <em>polytope</em>. We say <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> is the <em>dimensionality</em> of the polyhedron.</p>
</div>
<p>I already used the word <em>halfspace</em> without giving a formal definition. Let us remedy this.</p>
<div class="block">
<p><strong>Def</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>x</mi><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a,x\in \text{R}^n</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a\neq 0</annotation></semantics></math>.</p>
<ol style="list-style-type: decimal">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><mi>a</mi><mi>x</mi><mo>=</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{x|ax=b\}</annotation></semantics></math> is a <em>hyperplane</em> (a line in 2D)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><mi>a</mi><mi>x</mi><mo>≥</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{x|ax\geq b\}</annotation></semantics></math> is a <em>halfspace</em> (halfplane in 2D)</li>
</ol>
</div>
<p>With this definition we can say that a polyhedron is an intersection of a bunch of halfspaces.</p>
<h3 id="corners-of-polyhedra">Corners of Polyhedra</h3>
<p>A corner of a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-dimensional polyhedron is, intuitively, a point where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> edges meet. I will give a bunch of different definitions and them prove them to be equal.</p>
<p>The simplest definition uses a line. A corner of a polyhedron is a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> in the polyhedron where we can find a line that touches the polyhedron only at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</p>
<div class="block">
<p><strong>Def</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> be a polyhedron. A vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">x\in P</annotation></semantics></math> is a <em>vertex</em> of P if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mover><mi>c</mi><mo accent="true">⃗</mo></mover><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\exists \vec c\in \text{R}^n</annotation></semantics></math> s.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo>&lt;</mo><mi>c</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">cx &lt; cy</annotation></semantics></math> for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>P</mi><mo>,</mo><mi>y</mi><mo>≠</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y\in P, y \neq x</annotation></semantics></math>; that is, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is the minimal point for some cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> (the unique optimal solution for some LP with the feasible set P). See figure [Fig:vertex]</p>
<div class="figure">
<img src="./images/vertex.png" title="Fig:vertex" alt="[Fig:vertex] A vertex x is the optimal solution for a cost vector c" />
<p class="caption">[Fig:vertex] A vertex <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is the optimal solution for a cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math></p>
</div>
</div>
<p>Corners are interesting for optimization because the converse is also kind of true, at least for bounded polyhedra. For any cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>, we can find a vertex <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of the (bounded) polyhedron such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo>≤</mo><mi>c</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">cx \le cy</annotation></semantics></math> for all points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> in the polyhedron. There is no strict inequality here because the line defined by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> might be parallel to one of the edges of the polyhedron. If the polyhedron is not bounded, there are some <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> such that for any point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> there is a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">y&#39;</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>y</mi><mi>′</mi><mo>&lt;</mo><mi>c</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">cy&#39; &lt; cy</annotation></semantics></math>, that is, the optimal value for this cost vector is unbounded. These are of course the cost vectors that define a line that doesn’t leave the polyhedron.</p>
<p>However, we need some more definitions and theorems before we can prove the above statement.</p>
<div class="block">
<p><strong>Def</strong> An <em>extreme point</em> of a polyhedron P is a vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">x\in P</annotation></semantics></math> s.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not a convex combination of any two distinct vectors <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>,</mo><mi>z</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">y,z\in P</annotation></semantics></math> different from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>.</p>
</div>
<p>Convex combinations of two points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x,y</annotation></semantics></math> are all points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> for which the equation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">)</mo><mi>y</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\lambda x + (1-\lambda) y = z</annotation></semantics></math> has a solution for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>. Geometrically, the points <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> lie on a line between <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>. You can also take the convex combinations of more than two points. The principle is the same though, you add all the points, scaling each one with a non-negative scaling factor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math>. The combination is convex if the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\lambda_i</annotation></semantics></math> sum to 1.</p>
<p>Example: In 2D we can always select the two adjacent corners of a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> on the edge of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> if and only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not a corner. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> will be on the line between the two corners.</p>
<div class="block">
<p><strong>Def</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> be a polyhedron that is defined by some linear inequalities <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mi>i</mi></msub><annotation encoding="application/x-tex">a_i</annotation></semantics></math>: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>a</mi><mi>i</mi></msub><mi>x</mi><mo>≥</mo><msub><mi>b</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">P=\{x|a_ix\geq b_i\}</annotation></semantics></math>. We’ll say that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>-th constraint is <em>active</em> at a point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> if we have equality: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mi>x</mi><mo>=</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_ix = b_i</annotation></semantics></math></p>
</div>
<p>The constraints define the edges of polyhedron. If a point is on an edge that constraint is active. Intuitively the point must be a corner if it lies on the intersection of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> edges.</p>
<div class="block">
<p><strong>Def</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">P\in \text{R}^n</annotation></semantics></math> be a polyhedron in standard form and let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo>*</mo></msup><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^{*}\in \text{R}^n</annotation></semantics></math>. The vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mo>*</mo></msup><annotation encoding="application/x-tex">x^{*}</annotation></semantics></math> is a <em>basic solution</em> if at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mo>*</mo></msup><annotation encoding="application/x-tex">x^*</annotation></semantics></math> all equality constraints are active and there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> active constraints that are linearly independent. See solution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> in figure [Fig:bsfVSbs] for an example of a basic solution. If a basic solution is also feasible, we call it a <em>basic feasible solution</em> (b.f.s.). See the point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> in figure [Fig:bsfVSbs] for an example of a basic feasible solution.</p>
<div class="figure">
<img src="./images/basicVsBasicFeasible.png" title="Fig:bsfVSbs" alt="[Fig:bsfVSbs] Some LP. Solution A is a basic solution. Solution B is a basic feasible solution." />
<p class="caption">[Fig:bsfVSbs] Some LP. Solution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a basic solution. Solution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> is a basic feasible solution.</p>
</div>
</div>
<p>A polyhedron with fever than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> constraints never has a basic solution.</p>
<p>Now we want to prove that the three definitions are all equivalent to each other.</p>
<div class="block">
<p><strong>Theorem</strong> Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> be a polyhedron and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">x\in P</annotation></semantics></math>. The following statements are equivalent</p>
<ol style="list-style-type: decimal">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a vertex</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is an extreme point</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a basic feasible solution</li>
</ol>
</div>
<p><strong>Proof</strong></p>
<p>We show 1.) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 2.) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 3.) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 1.).</p>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a vertex <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is an extreme point: Proof by contraposition.</p>
<p>Assume the existence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>,</mo><mi>z</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">y,z \in P</annotation></semantics></math> both different from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a linear combination of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>, i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>λ</mi><mi>y</mi><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">)</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x= \lambda y + (1-\lambda )z</annotation></semantics></math>. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a linear combination of two vectors, it’s not an extreme point. We show that it is also not a vertex.</p>
<p>From the definition of vertex we know that some cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> should exist such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo>&lt;</mo><mi>c</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">c x &lt; c w</annotation></semantics></math>, for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">w\in P</annotation></semantics></math>, that is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is optimal w.r.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>. Together with the assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>λ</mi><mi>y</mi><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">)</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x= \lambda y + (1-\lambda )z</annotation></semantics></math> this leads to a contradiction.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right"><mi>c</mi><mi>x</mi></mtd><mtd columnalign="left"><mo>=</mo><mi>λ</mi><mi>c</mi><mi>y</mi><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">)</mo><mi>c</mi><mi>z</mi></mtd></mtr><mtr><mtd columnalign="right"></mtd><mtd columnalign="left"><mo>&gt;</mo><mi>λ</mi><mi>c</mi><mi>x</mi><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false" form="postfix">)</mo><mi>c</mi><mi>x</mi><mo>=</mo><mi>c</mi><mi>x</mi></mtd><mtd columnalign="right"></mtd><mtd columnalign="left"><mrow><mtext mathvariant="normal">since </mtext><mspace width="0.333em"></mspace></mrow><mi>c</mi><mi>x</mi><mo>&lt;</mo><mi>c</mi><mi>y</mi><mo>,</mo><mi>c</mi><mi>x</mi><mo>&lt;</mo><mi>c</mi><mi>z</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
cx &amp;= \lambda cy +(1-\lambda)cz\\
   &amp;&gt; \lambda cx + (1-\lambda)cx = cx &amp;&amp; \text{since }cx&lt; cy, cx&lt; cz\\\end{aligned}</annotation></semantics></math></p></li>
<li><p>extreme point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> bsf. Proof by contraposition.</p>
<p>Suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not a basic feasible solution. Then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is either not feasible, or not a basic solution. If it’s not feasible, then it can’t be an extreme point. Hence we can assume <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">x\in P</annotation></semantics></math> and it’s not a basic solution.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> be a matrix of active constraints at <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> the matrix of the inactive constraints such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>x</mi><mo>=</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">Bx=d</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>x</mi><mo>&gt;</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">Cx&gt;f</annotation></semantics></math>. Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not a bfs the matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> doesn’t have full rank and hence its kernel is nonempty. So we can find some vector in the kernel:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mi>δ</mi><mo>∈</mo><msup><mtext mathvariant="normal">R</mtext><mi>n</mi></msup><mo>,</mo><mi>δ</mi><mo>≠</mo><mn>0</mn><mo>:</mo><mspace width="0.222em"></mspace><mi>B</mi><mi>δ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\exists \delta \in \text{R}^n, \delta \neq 0:\ B\delta =0</annotation></semantics></math></p>
<p>With <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math> we define two vectors:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><mo>−</mo><mi>ϵ</mi><mi>δ</mi><mspace width="1.0em"></mspace><mi>z</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>ϵ</mi><mi>δ</mi></mrow><annotation encoding="application/x-tex">y=x-\epsilon \delta \quad z = x+\epsilon \delta</annotation></semantics></math></p>
<p>Note that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>+</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">x=(z+y)/2</annotation></semantics></math>. That means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not an extreme point if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>,</mo><mi>y</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">z,y \in P</annotation></semantics></math>, because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a convex combination of the two. Consider</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>z</mi><mo>=</mo><mi>B</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>+</mo><mi>ϵ</mi><mi>δ</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>B</mi><mi>x</mi><mo>+</mo><mi>ϵ</mi><mi>B</mi><mi>δ</mi><mo>=</mo><mi>B</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Bz = B(x+\epsilon \delta) = Bx + \epsilon B\delta = Bx</annotation></semantics></math></p>
<p>Since <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>δ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">B\delta = 0</annotation></semantics></math> the active constraints are still active. For the inactive constraints we have some slack before we leave the polyhedron. If we choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math> small enough we’re still within. It suffices to choose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ϵ</mi><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math> such that</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>i</mi><mo>:</mo><mi>ϵ</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>c</mi><mi>i</mi></msub><mi>z</mi><mo stretchy="false" form="prefix">|</mo><mo>&lt;</mo><msub><mi>c</mi><mi>i</mi></msub><mi>x</mi><mo>−</mo><msub><mi>f</mi><mi>i</mi></msub><mspace width="2.0em"></mspace><msub><mover><mi>c</mi><mo accent="true">⃗</mo></mover><mi>i</mi></msub><mo>∈</mo><mi>C</mi><mo>,</mo><mspace width="0.222em"></mspace><msub><mi>f</mi><mi>i</mi></msub><mo>∈</mo><mover><mi>f</mi><mo accent="true">⃗</mo></mover></mrow><annotation encoding="application/x-tex">\forall i: \epsilon |c_i z| &lt; c_i x - f_i\qquad \vec c_i\in C,\ f_i \in \vec f</annotation></semantics></math></p>
<p>That is, we make epsilon small enough such that we don’t violate the tightest of the constraints in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>.</p>
<p>Hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> (and analogous <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>) are still in the polyhedron and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not an extreme point.</p></li>
<li><p>bfs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> vertex: Suppose <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a bfs. We construct a cost vector for which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math> is the unique optimal solution.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> be the matrix of active constraints s.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Bx=b</annotation></semantics></math>. Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math> be the sum of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> rows of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>. We know the objective value for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> w.r.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>. It’s <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>x</mi><mo>=</mo><mo>∑</mo><msub><mi>b</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">c x = \sum b_i</annotation></semantics></math>.</p>
<p>Because <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> has rank <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is the unique solution to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>x</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">Bx=b</annotation></semantics></math>. For all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">y\in P</annotation></semantics></math> that are different from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>y</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">By &gt; b</annotation></semantics></math>, hence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is the optimal point for the cost vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>. Therefore <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is a vertex.</p></li>
</ul>
<hr/>
<div style="display:inline-flex;flex-wrap:wrap;justify-content:space-between;font-size:80%">
<p style="margin-right:2ex">CC-BY-SA <a href="mailto:adrian_neumann@gmx.de">Adrian Neumann</a> (PGP Key <a href="https://adriann.github.io/ressources/pub.asc">A0A8BC98</a>)</p>
<p style="margin-left:1ex;margin-right:1ex"><a href="http://adriann.github.io">adriann.github.io</a></p>
<p style="margin-left:2ex"><a href="https://adriann.github.io/feed.rss">RSS</a></p>
</div>
</body>
</html>
